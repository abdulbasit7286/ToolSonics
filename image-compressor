<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Image Compressor — Target Size Compression</title>

  <!-- SEO Meta Tags -->
  <meta name="title" content="Free Online Image Compressor | Compress JPG, PNG, WebP, AVIF">
  <meta name="description" content="Compress images online with adjustable quality and optional resize. Choose a target file size and the tool will try to reach it by adjusting quality. Preview before download.">
  <meta name="keywords" content="image compressor, compress image online, target size, jpg compressor, webp compressor, avif compressor, reduce image size">
  <meta name="author" content="Your Website Name">
  <meta name="robots" content="index, follow">

  <style>
    :root{
      --blue:#0d6efd;
      --blue-2:#0b5ed7;
      --bg:#ffffff;
      --muted:#6b7280;
      --radius:12px;
      font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#f6fbff,#ffffff);color:#0f1724;padding:18px;display:flex;align-items:center;justify-content:center;min-height:100vh}
    .card{width:100%;max-width:1040px;background:var(--bg);border-radius:16px;padding:18px;box-shadow:0 12px 40px rgba(13,110,253,0.06);border:1px solid rgba(13,110,253,0.04)}
    header{display:flex;gap:12px;align-items:center}
    .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--blue),var(--blue-2));display:flex;align-items:center;justify-content:center;color:white;font-weight:700}
    h1{font-size:18px;margin:0}
    p.lead{margin:0;color:var(--muted);font-size:13px}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:18px;margin-top:16px}
    .panel{padding:12px;border-radius:12px;background:linear-gradient(180deg,#fff,#fbfdff);border:1px solid rgba(13,110,253,0.03)}
    .drop{border:2px dashed rgba(13,110,253,0.14);border-radius:10px;padding:14px;text-align:center;cursor:pointer}
    .drop.dragover{border-color:var(--blue);background:rgba(13,110,253,0.03)}
    input[type=file]{display:none}
    .controls{display:flex;flex-direction:column;gap:10px;margin-top:12px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    label.select{background:white;border:1px solid rgba(13,110,253,0.06);padding:8px 10px;border-radius:10px;display:flex;align-items:center;gap:8px;font-size:14px}
    .btn{padding:10px 12px;border-radius:10px;border:0;cursor:pointer}
    .btn-primary{background:var(--blue);color:white;font-weight:600}
    .btn-ghost{background:transparent;border:1px solid rgba(13,110,253,0.12)}
    .thumb{width:100%;height:340px;background:linear-gradient(90deg,#f3f7ff,#fff);border-radius:10px;display:flex;align-items:center;justify-content:center;overflow:hidden}
    .thumb img{max-width:100%;max-height:100%;object-fit:contain}
    .small{font-size:13px;color:var(--muted)}
    .meta-row{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .pill{background:#f8fafc;padding:6px 8px;border-radius:999px;border:1px solid rgba(15,23,36,0.04);font-size:13px}
    footer{margin-top:16px;text-align:center;color:var(--muted);font-size:13px}
    @media (max-width:980px){ .grid{grid-template-columns:1fr} .thumb{height:220px} .logo{width:48px;height:48px} }
    .spinner{border:4px solid rgba(0,0,0,0.05);border-top:4px solid var(--blue);border-radius:50%;width:36px;height:36px;animation:spin 1s linear infinite;margin:auto}
    @keyframes spin{to{transform:rotate(360deg)}}
    .progressbar{height:8px;background:#eef2ff;border-radius:999px;overflow:hidden;width:100%}
    .progressbar > i{display:block;height:100%;background:linear-gradient(90deg,var(--blue),var(--blue-2));width:0%}
  </style>
</head>
<body>
  <main class="card" role="main">
    <header>
      <div class="logo">CMP</div>
      <div>
        <h1>Image Compressor — Target Size Mode</h1>
        <p class="lead">Upload an image, set a target file size (KB), or adjust quality/resizing. Preview & download compressed image.</p>
      </div>
    </header>

    <section class="grid" aria-live="polite">
      <div class="panel">
        <div id="dropZone" class="drop" tabindex="0" aria-label="Upload image dropzone">
          <strong>Drag & drop or click to upload</strong>
          <div style="margin-top:6px" class="small">PNG, JPG, JPEG, WebP, AVIF — max 25 MB</div>
          <input id="fileInput" type="file" accept="image/*" />
        </div>

        <div class="controls">
          <div class="row">
            <label class="select">Format
              <select id="formatSelect" aria-label="Output format">
                <option value="image/jpeg">JPG</option>
                <option value="image/webp">WebP</option>
                <option value="image/avif">AVIF</option>
                <option value="image/png">PNG (lossless)</option>
              </select>
            </label>

            <label class="select">Quality
              <input id="quality" type="range" min="10" max="100" value="85" aria-label="Quality slider" />
              <span id="qVal">85%</span>
            </label>

            <label class="select">Max Width (px)
              <input id="maxWidth" type="number" placeholder="auto" style="width:110px" aria-label="Max width" />
            </label>
          </div>

          <div class="row">
            <label class="select">Target size (KB)
              <input id="targetKB" type="number" placeholder="e.g. 200" style="width:110px" aria-label="Target size in KB" />
            </label>

            <label class="select">
              Min Quality
              <input id="minQuality" type="number" min="10" max="90" value="30" style="width:110px" />
            </label>

            <label class="select">
              Step %
              <input id="stepQuality" type="number" min="1" max="20" value="5" style="width:110px" />
            </label>
          </div>

          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="compressBtn" class="btn btn-primary">Compress (Target)</button>
            <a id="downloadLink" class="btn btn-primary" style="display:none" download>Download</a>
            <button id="resetBtn" class="btn btn-ghost">Reset</button>
          </div>

          <div class="meta-row">
            <div>Original: <span id="origInfo" class="pill">—</span></div>
            <div>Compressed: <span id="newInfo" class="pill">—</span></div>
            <div id="dimsInfo" class="pill">—</div>
          </div>

          <div style="margin-top:10px">
            <div class="progressbar" aria-hidden="true"><i id="progressFill" style="width:0%"></i></div>
            <div id="progressText" class="small" style="text-align:right;margin-top:6px"></div>
          </div>
        </div>
      </div>

      <aside class="panel">
        <div class="thumb" id="preview"><span class="small">Preview will appear here</span></div>
      </aside>
    </section>

    <footer>
      Made for your multi-tool website · Bright blue & white theme
      <section style="margin-top:12px;color:#555;font-size:13px;max-width:860px;margin-inline:auto">
        <p><strong>SEO:</strong> Free Image Compressor — compress JPG, PNG, WebP, AVIF online. Target-size compression, adjustable quality & resize, preview and download. Client-side processing for privacy.</p>
      </section>
    </footer>
  </main>

  <script>
    // DOM
    const fileInput = document.getElementById('fileInput');
    const dropZone = document.getElementById('dropZone');
    const preview = document.getElementById('preview');
    const compressBtn = document.getElementById('compressBtn');
    const downloadLink = document.getElementById('downloadLink');
    const resetBtn = document.getElementById('resetBtn');
    const formatSelect = document.getElementById('formatSelect');
    const qualityInput = document.getElementById('quality');
    const qVal = document.getElementById('qVal');
    const maxWidthInput = document.getElementById('maxWidth');
    const origInfo = document.getElementById('origInfo');
    const newInfo = document.getElementById('newInfo');
    const dimsInfo = document.getElementById('dimsInfo');
    const targetKB = document.getElementById('targetKB');
    const minQualityInput = document.getElementById('minQuality');
    const stepQualityInput = document.getElementById('stepQuality');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');

    let currentFile = null;
    let currentImage = null;
    let currentBlobUrl = null;
    let outBlobUrl = null;

    function humanBytes(bytes){
      if(!bytes) return '0 B';
      const thresh = 1024;
      if(Math.abs(bytes) < thresh) return bytes + ' B';
      const units = ['KB','MB','GB','TB'];
      let u = -1;
      do { bytes /= thresh; ++u; } while(Math.abs(bytes) >= thresh && u < units.length - 1);
      return bytes.toFixed(2) + ' ' + units[u];
    }

    // Drag & drop UX
    ['dragenter','dragover'].forEach(ev => dropZone.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); dropZone.classList.add('dragover'); }));
    ['dragleave','drop'].forEach(ev => dropZone.addEventListener(ev, e => { e.preventDefault(); e.stopPropagation(); dropZone.classList.remove('dragover'); }));
    dropZone.addEventListener('drop', e => {
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if(f) handleFile(f);
    });
    dropZone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', e => { if(e.target.files && e.target.files[0]) handleFile(e.target.files[0]); });

    qualityInput.addEventListener('input', ()=> qVal.textContent = qualityInput.value + '%');

    function handleFile(file){
      if(!file.type.startsWith('image/')){ alert('Please upload an image file.'); return; }
      if(file.size > 25 * 1024 * 1024){ alert('File too large (max 25 MB).'); return; }

      // cleanup
      if(currentBlobUrl) try{ URL.revokeObjectURL(currentBlobUrl); }catch(e){}
      if(outBlobUrl) try{ URL.revokeObjectURL(outBlobUrl); }catch(e){}

      currentFile = file;
      origInfo.textContent = humanBytes(file.size);
      newInfo.textContent = '—';
      progressFill.style.width = '0%';
      progressText.textContent = '';

      const url = URL.createObjectURL(file);
      currentBlobUrl = url;
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        currentImage = img;
        renderPreview(img);
        dimsInfo.textContent = img.naturalWidth + ' × ' + img.naturalHeight;
      };
      img.onerror = () => {
        currentImage = null;
        preview.innerHTML = '<div class="small">Preview not available — try compressing directly.</div>';
      };
      img.src = url;
    }

    function renderPreview(img){
      preview.innerHTML = '';
      img.style.maxWidth = '100%';
      img.style.maxHeight = '100%';
      img.style.objectFit = 'contain';
      preview.appendChild(img);
    }

    // decode helper - prefer ImageBitmap
    async function getDrawable(){
      if(window.createImageBitmap && currentFile){
        try{
          const bitmap = await createImageBitmap(currentFile);
          return { type:'bitmap', src: bitmap };
        }catch(e){
          console.warn('createImageBitmap failed', e);
        }
      }
      if(currentImage && currentImage.complete && currentImage.naturalWidth && currentImage.naturalHeight){
        return { type:'img', src: currentImage };
      }
      // fallback attempt
      return new Promise((resolve, reject) => {
        if(!currentFile) return reject(new Error('No file'));
        const tmp = new Image();
        tmp.crossOrigin = 'anonymous';
        const u = URL.createObjectURL(currentFile);
        let done=false;
        tmp.onload = ()=>{ if(done) return; done=true; try{ URL.revokeObjectURL(u); }catch(e){} resolve({type:'img', src:tmp}); };
        tmp.onerror = ()=>{ if(done) return; done=true; try{ URL.revokeObjectURL(u); }catch(e){} reject(new Error('Failed to decode image')); };
        tmp.src = u;
        setTimeout(()=>{ if(!done){ done=true; try{ URL.revokeObjectURL(u); }catch(e){} reject(new Error('Image decode timed out')); } }, 15000);
      });
    }

    // generic compress once with given quality
    async function compressOnce(drawable, mime, qualityNormalized, maxWidth){
      const srcW = (drawable.type === 'bitmap') ? drawable.src.width : drawable.src.naturalWidth;
      const srcH = (drawable.type === 'bitmap') ? drawable.src.height : drawable.src.naturalHeight;
      if(!srcW || !srcH) throw new Error('Invalid image dimensions');

      let outW = srcW, outH = srcH;
      if(maxWidth && outW > maxWidth){
        const s = maxWidth / outW;
        outW = Math.round(outW * s);
        outH = Math.round(outH * s);
      }

      const canvas = document.createElement('canvas');
      canvas.width = outW; canvas.height = outH;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,outW,outH);
      try{
        ctx.drawImage(drawable.src, 0, 0, outW, outH);
      }catch(e){
        if(drawable.type === 'bitmap' && typeof drawable.src.close === 'function') try{ drawable.src.close(); }catch(er){}
        throw new Error('Failed to draw image: ' + (e && e.message));
      }
      if(drawable.type === 'bitmap' && typeof drawable.src.close === 'function') try{ drawable.src.close(); }catch(e){}

      const qArg = (mime === 'image/png') ? undefined : qualityNormalized;
      return new Promise((resolve, reject) => {
        try{
          canvas.toBlob(blob => {
            if(!blob) return reject(new Error('toBlob returned null'));
            resolve({ blob, canvas });
          }, mime, qArg);
        }catch(err){
          reject(err);
        }
      });
    }

    // iterative compression to target size (KB)
    async function compressToTarget(opts){
      // opts: { mime, targetBytes, startQuality(0-1), minQuality(0-1), stepQuality(0-1), maxWidth }
      const drawable = await getDrawable();
      const mime = opts.mime;
      const maxWidth = opts.maxWidth;
      const target = opts.targetBytes;
      const minQ = opts.minQuality;
      const stepQ = opts.stepQuality;
      let q = opts.startQuality;

      // if target is null, just compress once with given quality
      if(!target || target <= 0){
        const result = await compressOnce(drawable, mime, q, maxWidth);
        return { best: result, achieved:false };
      }

      // start iterative loop: try descending quality until hit target or minQ
      let best = null;
      let bestSize = Infinity;
      let iterations = 0;
      const maxIter = Math.ceil((q - minQ) / stepQ) + 3;

      while(q >= minQ && iterations < 60){
        iterations++;
        progressFill.style.width = Math.min(100, Math.round(((opts.startQuality - q) / (opts.startQuality - minQ + 0.0001)) * 100)) + '%';
        progressText.textContent = `Trying quality ${(q*100).toFixed(0)}% (step ${Math.round(stepQ*100)}%)`;
        try{
          const result = await compressOnce(drawable, mime, q, maxWidth);
          const size = result.blob.size;
          if(size <= target){
            // good enough: return this
            return { best: result, achieved:true, quality:q, iterations };
          }
          // keep best (smallest) so far
          if(size < bestSize){
            bestSize = size;
            best = result;
          }else{
            // if size increased unexpectedly, still keep best
          }
        }catch(err){
          console.warn('compressOnce failed at q=', q, err);
          // continue decreasing quality
        }
        q = +(q - stepQ).toFixed(3);
        if(q <= 0) break;
      }

      // if loop ends without hitting target, return smallest found
      if(best) return { best, achieved:false, bestSize, iterations };
      // fallback: do single compress with minQ
      const fallback = await compressOnce(drawable, mime, minQ, maxWidth);
      return { best: fallback, achieved:false, iterations };
    }

    // UI handler
    compressBtn.addEventListener('click', async () => {
      if(!currentFile){ alert('Please upload an image first.'); return; }
      compressBtn.disabled = true;
      compressBtn.textContent = 'Working...';
      downloadLink.style.display = 'none';
      progressFill.style.width = '0%';
      progressText.textContent = '';

      const mime = formatSelect.value || 'image/jpeg';
      const startQ = (mime === 'image/png') ? 1 : (parseInt(qualityInput.value,10) || 85) / 100;
      const minQ = Math.max(0.05, (parseInt(minQualityInput.value,10) || 30) / 100);
      const stepQ = Math.max(0.01, (parseInt(stepQualityInput.value,10) || 5) / 100);
      const maxW = parseInt(maxWidthInput.value,10) || null;
      const target = parseInt(targetKB.value,10) ? (parseInt(targetKB.value,10) * 1024) : null;

      try{
        const res = await compressToTarget({
          mime,
          targetBytes: target,
          startQuality: startQ,
          minQuality: minQ,
          stepQuality: stepQ,
          maxWidth: maxW
        });

        const { best, achieved } = res;
        if(!best || !best.blob){ throw new Error('Compression returned no blob'); }

        // prepare download/preview
        if(outBlobUrl) try{ URL.revokeObjectURL(outBlobUrl); }catch(e){}
        outBlobUrl = URL.createObjectURL(best.blob);
        downloadLink.href = outBlobUrl;
        const ext = (mime.split('/')[1] || 'jpg').replace('jpeg','jpg');
        const baseName = (currentFile && currentFile.name) ? currentFile.name.replace(/\.[^.]+$/,'') : 'compressed-image';
        downloadLink.download = `${baseName}.${ext}`;
        downloadLink.style.display = '';
        newInfo.textContent = humanBytes(best.blob.size);
        progressFill.style.width = '100%';
        progressText.textContent = achieved ? 'Target reached' : 'Finished (closest result)';
        // show preview
        const pi = new Image();
        pi.onload = ()=>{ preview.innerHTML=''; pi.style.maxWidth='100%'; pi.style.maxHeight='100%'; pi.style.objectFit='contain'; preview.appendChild(pi); };
        pi.onerror = ()=>{ preview.innerHTML = '<div class="small">Compressed preview not available</div>'; };
        pi.src = outBlobUrl;

      }catch(err){
        console.error(err);
        alert('Compression error: ' + (err && err.message ? err.message : 'unknown'));
      }finally{
        compressBtn.disabled = false;
        compressBtn.textContent = 'Compress (Target)';
      }
    });

    // reset
    resetBtn.addEventListener('click', ()=> {
      if(currentBlobUrl) try{ URL.revokeObjectURL(currentBlobUrl); }catch(e){}
      if(outBlobUrl) try{ URL.revokeObjectURL(outBlobUrl); }catch(e){}
      currentBlobUrl = outBlobUrl = null;
      currentFile = null;
      currentImage = null;
      preview.innerHTML = '<span class="small">Preview will appear here</span>';
      downloadLink.style.display = 'none';
      origInfo.textContent = '—';
      newInfo.textContent = '—';
      dimsInfo.textContent = '—';
      maxWidthInput.value = '';
      qualityInput.value = '85';
      qVal.textContent = '85%';
      targetKB.value = '';
      minQualityInput.value = '30';
      stepQualityInput.value = '5';
      fileInput.value = '';
      progressFill.style.width = '0%';
      progressText.textContent = '';
    });

    // accessibility
    dropZone.addEventListener('keydown', e => { if(e.key === 'Enter' || e.key === ' ') fileInput.click(); });

    // init
    (function(){ qVal.textContent = qualityInput.value + '%'; origInfo.textContent='—'; newInfo.textContent='—'; dimsInfo.textContent='—'; })();

  </script>
</body>
</html>
